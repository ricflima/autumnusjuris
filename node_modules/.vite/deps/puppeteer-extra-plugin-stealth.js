import {
  require_browser
} from "./chunk-7SENDFOF.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-Y7JXYYDW.js";

// node_modules/arr-union/index.js
var require_arr_union = __commonJS({
  "node_modules/arr-union/index.js"(exports, module) {
    "use strict";
    module.exports = function union(init) {
      if (!Array.isArray(init)) {
        throw new TypeError("arr-union expects the first argument to be an array.");
      }
      var len = arguments.length;
      var i = 0;
      while (++i < len) {
        var arg = arguments[i];
        if (!arg) continue;
        if (!Array.isArray(arg)) {
          arg = [arg];
        }
        for (var j = 0; j < arg.length; j++) {
          var ele = arg[j];
          if (init.indexOf(ele) >= 0) {
            continue;
          }
          init.push(ele);
        }
      }
      return init;
    };
  }
});

// node_modules/lazy-cache/index.js
var require_lazy_cache = __commonJS({
  "node_modules/lazy-cache/index.js"(exports, module) {
    "use strict";
    function lazyCache(fn) {
      var cache = {};
      var proxy = function(mod, name) {
        name = name || camelcase(mod);
        if (process.env.UNLAZY === "true" || process.env.UNLAZY === true || process.env.TRAVIS) {
          cache[name] = fn(mod);
        }
        Object.defineProperty(proxy, name, {
          enumerable: true,
          configurable: true,
          get: getter
        });
        function getter() {
          if (cache.hasOwnProperty(name)) {
            return cache[name];
          }
          return cache[name] = fn(mod);
        }
        return getter;
      };
      return proxy;
    }
    function camelcase(str) {
      if (str.length === 1) {
        return str.toLowerCase();
      }
      str = str.replace(/^[\W_]+|[\W_]+$/g, "").toLowerCase();
      return str.replace(/[\W_]+(\w|$)/g, function(_, ch) {
        return ch.toUpperCase();
      });
    }
    module.exports = lazyCache;
  }
});

// node_modules/for-in/index.js
var require_for_in = __commonJS({
  "node_modules/for-in/index.js"(exports, module) {
    "use strict";
    module.exports = function forIn(obj, fn, thisArg) {
      for (var key in obj) {
        if (fn.call(thisArg, obj[key], key, obj) === false) {
          break;
        }
      }
    };
  }
});

// node_modules/for-own/index.js
var require_for_own = __commonJS({
  "node_modules/for-own/index.js"(exports, module) {
    "use strict";
    var forIn = require_for_in();
    var hasOwn = Object.prototype.hasOwnProperty;
    module.exports = function forOwn(obj, fn, thisArg) {
      forIn(obj, function(val, key) {
        if (hasOwn.call(obj, key)) {
          return fn.call(thisArg, obj[key], key, obj);
        }
      });
    };
  }
});

// node_modules/clone-deep/utils.js
var require_utils = __commonJS({
  "node_modules/clone-deep/utils.js"(exports, module) {
    "use strict";
    var utils = require_lazy_cache()(__require);
    var fn = __require;
    __require = utils;
    __require("is-plain-object", "isObject");
    __require("shallow-clone", "clone");
    __require("kind-of", "typeOf");
    require_for_own();
    __require = fn;
    module.exports = utils;
  }
});

// node_modules/clone-deep/index.js
var require_clone_deep = __commonJS({
  "node_modules/clone-deep/index.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function cloneDeep(val, instanceClone) {
      switch (utils.typeOf(val)) {
        case "object":
          return cloneObjectDeep(val, instanceClone);
        case "array":
          return cloneArrayDeep(val, instanceClone);
        default:
          return utils.clone(val);
      }
    }
    function cloneObjectDeep(obj, instanceClone) {
      if (utils.isObject(obj)) {
        var res = {};
        utils.forOwn(obj, function(obj2, key) {
          this[key] = cloneDeep(obj2, instanceClone);
        }, res);
        return res;
      } else if (instanceClone) {
        return instanceClone(obj);
      } else {
        return obj;
      }
    }
    function cloneArrayDeep(arr, instanceClone) {
      var len = arr.length, res = [];
      var i = -1;
      while (++i < len) {
        res[i] = cloneDeep(arr[i], instanceClone);
      }
      return res;
    }
    module.exports = cloneDeep;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "node_modules/kind-of/index.js"(exports, module) {
    var isBuffer = require_is_buffer();
    var toString = Object.prototype.toString;
    module.exports = function kindOf(val) {
      if (typeof val === "undefined") {
        return "undefined";
      }
      if (val === null) {
        return "null";
      }
      if (val === true || val === false || val instanceof Boolean) {
        return "boolean";
      }
      if (typeof val === "string" || val instanceof String) {
        return "string";
      }
      if (typeof val === "number" || val instanceof Number) {
        return "number";
      }
      if (typeof val === "function" || val instanceof Function) {
        return "function";
      }
      if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
        return "array";
      }
      if (val instanceof RegExp) {
        return "regexp";
      }
      if (val instanceof Date) {
        return "date";
      }
      var type = toString.call(val);
      if (type === "[object RegExp]") {
        return "regexp";
      }
      if (type === "[object Date]") {
        return "date";
      }
      if (type === "[object Arguments]") {
        return "arguments";
      }
      if (type === "[object Error]") {
        return "error";
      }
      if (isBuffer(val)) {
        return "buffer";
      }
      if (type === "[object Set]") {
        return "set";
      }
      if (type === "[object WeakSet]") {
        return "weakset";
      }
      if (type === "[object Map]") {
        return "map";
      }
      if (type === "[object WeakMap]") {
        return "weakmap";
      }
      if (type === "[object Symbol]") {
        return "symbol";
      }
      if (type === "[object Int8Array]") {
        return "int8array";
      }
      if (type === "[object Uint8Array]") {
        return "uint8array";
      }
      if (type === "[object Uint8ClampedArray]") {
        return "uint8clampedarray";
      }
      if (type === "[object Int16Array]") {
        return "int16array";
      }
      if (type === "[object Uint16Array]") {
        return "uint16array";
      }
      if (type === "[object Int32Array]") {
        return "int32array";
      }
      if (type === "[object Uint32Array]") {
        return "uint32array";
      }
      if (type === "[object Float32Array]") {
        return "float32array";
      }
      if (type === "[object Float64Array]") {
        return "float64array";
      }
      return "object";
    };
  }
});

// node_modules/merge-deep/index.js
var require_merge_deep = __commonJS({
  "node_modules/merge-deep/index.js"(exports, module) {
    "use strict";
    var union = require_arr_union();
    var clone = require_clone_deep();
    var typeOf = require_kind_of();
    module.exports = function mergeDeep(orig, objects) {
      if (!isObject(orig) && !Array.isArray(orig)) {
        orig = {};
      }
      var target = clone(orig);
      var len = arguments.length;
      var idx = 0;
      while (++idx < len) {
        var val = arguments[idx];
        if (isObject(val) || Array.isArray(val)) {
          merge2(target, val);
        }
      }
      return target;
    };
    function merge2(target, obj) {
      for (var key in obj) {
        if (!isValidKey(key) || !hasOwn(obj, key)) {
          continue;
        }
        var oldVal = obj[key];
        var newVal = target[key];
        if (isObject(newVal) && isObject(oldVal)) {
          target[key] = merge2(newVal, oldVal);
        } else if (Array.isArray(newVal)) {
          target[key] = union([], newVal, oldVal);
        } else {
          target[key] = clone(oldVal);
        }
      }
      return target;
    }
    function hasOwn(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    function isObject(val) {
      return typeOf(val) === "object" || typeOf(val) === "function";
    }
    function isValidKey(key) {
      return key !== "__proto__" && key !== "constructor" && key !== "prototype";
    }
  }
});

// node_modules/puppeteer-extra-plugin/dist/index.esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  PuppeteerExtraPlugin: () => PuppeteerExtraPlugin
});
var import_debug, merge, PuppeteerExtraPlugin;
var init_index_esm = __esm({
  "node_modules/puppeteer-extra-plugin/dist/index.esm.js"() {
    import_debug = __toESM(require_browser());
    merge = require_merge_deep();
    PuppeteerExtraPlugin = class {
      constructor(opts) {
        this._debugBase = (0, import_debug.default)(`puppeteer-extra-plugin:base:${this.name}`);
        this._childClassMembers = [];
        this._opts = merge(this.defaults, opts || {});
        this._debugBase("Initialized.");
      }
      /**
       * Plugin name (required).
       *
       * Convention:
       * - Package: `puppeteer-extra-plugin-anonymize-ua`
       * - Name: `anonymize-ua`
       *
       * @example
       * get name () { return 'anonymize-ua' }
       */
      get name() {
        throw new Error('Plugin must override "name"');
      }
      /**
       * Plugin defaults (optional).
       *
       * If defined will be ([deep-](https://github.com/jonschlinkert/merge-deep))merged with the (optional) user supplied options (supplied during plugin instantiation).
       *
       * The result of merging defaults with user supplied options can be accessed through `this.opts`.
       *
       * @see [[opts]]
       *
       * @example
       * get defaults () {
       *   return {
       *     stripHeadless: true,
       *     makeWindows: true,
       *     customFn: null
       *   }
       * }
       *
       * // Users can overwrite plugin defaults during instantiation:
       * puppeteer.use(require('puppeteer-extra-plugin-foobar')({ makeWindows: false }))
       */
      get defaults() {
        return {};
      }
      /**
       * Plugin requirements (optional).
       *
       * Signal certain plugin requirements to the base class and the user.
       *
       * Currently supported:
       * - `launch`
       *   - If the plugin only supports locally created browser instances (no `puppeteer.connect()`),
       *     will output a warning to the user.
       * - `headful`
       *   - If the plugin doesn't work in `headless: true` mode,
       *     will output a warning to the user.
       * - `dataFromPlugins`
       *   - In case the plugin requires data from other plugins.
       *     will enable usage of `this.getDataFromPlugins()`.
       * - `runLast`
       *   - In case the plugin prefers to run after the others.
       *     Useful when the plugin needs data from others.
       *
       * @example
       * get requirements () {
       *   return new Set(['runLast', 'dataFromPlugins'])
       * }
       */
      get requirements() {
        return /* @__PURE__ */ new Set([]);
      }
      /**
       * Plugin dependencies (optional).
       *
       * Missing plugins will be required() by puppeteer-extra.
       *
       * @example
       * get dependencies () {
       *   return new Set(['user-preferences'])
       * }
       * // Will ensure the 'puppeteer-extra-plugin-user-preferences' plugin is loaded.
       */
      get dependencies() {
        return /* @__PURE__ */ new Set([]);
      }
      /**
       * Plugin data (optional).
       *
       * Plugins can expose data (an array of objects), which in turn can be consumed by other plugins,
       * that list the `dataFromPlugins` requirement (by using `this.getDataFromPlugins()`).
       *
       * Convention: `[ {name: 'Any name', value: 'Any value'} ]`
       *
       * @see [[getDataFromPlugins]]
       *
       * @example
       * // plugin1.js
       * get data () {
       *   return [
       *     {
       *       name: 'userPreferences',
       *       value: { foo: 'bar' }
       *     },
       *     {
       *       name: 'userPreferences',
       *       value: { hello: 'world' }
       *     }
       *   ]
       *
       * // plugin2.js
       * get requirements () { return new Set(['dataFromPlugins']) }
       *
       * async beforeLaunch () {
       *   const prefs = this.getDataFromPlugins('userPreferences').map(d => d.value)
       *   this.debug(prefs) // => [ { foo: 'bar' }, { hello: 'world' } ]
       * }
       */
      get data() {
        return [];
      }
      /**
       * Access the plugin options (usually the `defaults` merged with user defined options)
       *
       * To skip the auto-merging of defaults with user supplied opts don't define a `defaults`
       * property and set the `this._opts` Object in your plugin constructor directly.
       *
       * @see [[defaults]]
       *
       * @example
       * get defaults () { return { foo: "bar" } }
       *
       * async onPageCreated (page) {
       *   this.debug(this.opts.foo) // => bar
       * }
       */
      get opts() {
        return this._opts;
      }
      /**
       *  Convenience debug logger based on the [debug] module.
       *  Will automatically namespace the logging output to the plugin package name.
       *  [debug]: https://www.npmjs.com/package/debug
       *
       *  ```bash
       *  # toggle output using environment variables
       *  DEBUG=puppeteer-extra-plugin:<plugin_name> node foo.js
       *  # to debug all the things:
       *  DEBUG=puppeteer-extra,puppeteer-extra-plugin:* node foo.js
       *  ```
       *
       * @example
       * this.debug('hello world')
       * // will output e.g. 'puppeteer-extra-plugin:anonymize-ua hello world'
       */
      get debug() {
        return (0, import_debug.default)(`puppeteer-extra-plugin:${this.name}`);
      }
      /**
       * Before a new browser instance is created/launched.
       *
       * Can be used to modify the puppeteer launch options by modifying or returning them.
       *
       * Plugins using this method will be called in sequence to each
       * be able to update the launch options.
       *
       * @example
       * async beforeLaunch (options) {
       *   if (this.opts.flashPluginPath) {
       *     options.args.push(`--ppapi-flash-path=${this.opts.flashPluginPath}`)
       *   }
       * }
       *
       * @param options - Puppeteer launch options
       */
      async beforeLaunch(options) {
      }
      /**
       * After the browser has launched.
       *
       * Note: Don't assume that there will only be a single browser instance during the lifecycle of a plugin.
       * It's possible that `pupeeteer.launch` will be  called multiple times and more than one browser created.
       * In order to make the plugins as stateless as possible don't store a reference to the browser instance
       * in the plugin but rather consider alternatives.
       *
       * E.g. when using `onPageCreated` you can get a browser reference by using `page.browser()`.
       *
       * Alternatively you could expose a class method that takes a browser instance as a parameter to work with:
       *
       * ```es6
       * const fancyPlugin = require('puppeteer-extra-plugin-fancy')()
       * puppeteer.use(fancyPlugin)
       * const browser = await puppeteer.launch()
       * await fancyPlugin.killBrowser(browser)
       * ```
       *
       * @param  browser - The `puppeteer` browser instance.
       * @param  opts.options - Puppeteer launch options used.
       *
       * @example
       * async afterLaunch (browser, opts) {
       *   this.debug('browser has been launched', opts.options)
       * }
       */
      async afterLaunch(browser, opts = { options: {} }) {
      }
      /**
       * Before connecting to an existing browser instance.
       *
       * Can be used to modify the puppeteer connect options by modifying or returning them.
       *
       * Plugins using this method will be called in sequence to each
       * be able to update the launch options.
       *
       * @param  {Object} options - Puppeteer connect options
       * @return {Object=}
       */
      async beforeConnect(options) {
      }
      /**
       * After connecting to an existing browser instance.
       *
       * > Note: Don't assume that there will only be a single browser instance during the lifecycle of a plugin.
       *
       * @param browser - The `puppeteer` browser instance.
       * @param  {Object} opts
       * @param  {Object} opts.options - Puppeteer connect options used.
       *
       */
      async afterConnect(browser, opts = {}) {
      }
      /**
       * Called when a browser instance is available.
       *
       * This applies to both `puppeteer.launch()` and `puppeteer.connect()`.
       *
       * Convenience method created for plugins that need access to a browser instance
       * and don't mind if it has been created through `launch` or `connect`.
       *
       * > Note: Don't assume that there will only be a single browser instance during the lifecycle of a plugin.
       *
       * @param browser - The `puppeteer` browser instance.
       */
      async onBrowser(browser, opts) {
      }
      /**
       * Called when a target is created, for example when a new page is opened by window.open or browser.newPage.
       *
       * > Note: This includes target creations in incognito browser contexts.
       *
       * > Note: This includes browser instances created through `.launch()` as well as `.connect()`.
       *
       * @param  {Puppeteer.Target} target
       */
      async onTargetCreated(target) {
      }
      /**
       * Same as `onTargetCreated` but prefiltered to only contain Pages, for convenience.
       *
       * > Note: This includes page creations in incognito browser contexts.
       *
       * > Note: This includes browser instances created through `.launch()` as well as `.connect()`.
       *
       * @param  {Puppeteer.Target} target
       *
       * @example
       * async onPageCreated (page) {
       *   let ua = await page.browser().userAgent()
       *   if (this.opts.stripHeadless) {
       *     ua = ua.replace('HeadlessChrome/', 'Chrome/')
       *   }
       *   this.debug('new ua', ua)
       *   await page.setUserAgent(ua)
       * }
       */
      async onPageCreated(page) {
      }
      /**
       * Called when the url of a target changes.
       *
       * > Note: This includes target changes in incognito browser contexts.
       *
       * > Note: This includes browser instances created through `.launch()` as well as `.connect()`.
       *
       * @param  {Puppeteer.Target} target
       */
      async onTargetChanged(target) {
      }
      /**
       * Called when a target is destroyed, for example when a page is closed.
       *
       * > Note: This includes target destructions in incognito browser contexts.
       *
       * > Note: This includes browser instances created through `.launch()` as well as `.connect()`.
       *
       * @param  {Puppeteer.Target} target
       */
      async onTargetDestroyed(target) {
      }
      /**
       * Called when Puppeteer gets disconnected from the Chromium instance.
       *
       * This might happen because of one of the following:
       * - Chromium is closed or crashed
       * - The `browser.disconnect` method was called
       */
      async onDisconnected() {
      }
      /**
       * **Deprecated:** Since puppeteer v1.6.0 `onDisconnected` has been improved
       * and should be used instead of `onClose`.
       *
       * In puppeteer < v1.6.0 `onDisconnected` was not catching all exit scenarios.
       * In order for plugins to clean up properly (e.g. deleting temporary files)
       * the `onClose` method had been introduced.
       *
       * > Note: Might be called multiple times on exit.
       *
       * > Note: This only includes browser instances created through `.launch()`.
       */
      async onClose() {
      }
      /**
       * After the plugin has been registered in `puppeteer-extra`.
       *
       * Normally right after `puppeteer.use(plugin)` is called
       */
      async onPluginRegistered() {
      }
      /**
       * Helper method to retrieve `data` objects from other plugins.
       *
       * A plugin needs to state the `dataFromPlugins` requirement
       * in order to use this method. Will be mapped to `puppeteer.getPluginData`.
       *
       * @param name - Filter data by `name` property
       *
       * @see [data]
       * @see [requirements]
       */
      getDataFromPlugins(name) {
        return [];
      }
      /**
       * Will match plugin dependencies against all currently registered plugins.
       * Is being called by `puppeteer-extra` and used to require missing dependencies.
       *
       * @param  {Array<Object>} plugins
       * @return {Set} - list of missing plugin names
       *
       * @private
       */
      _getMissingDependencies(plugins) {
        const pluginNames = new Set(plugins.map((p) => p.name));
        const missing = new Set(Array.from(this.dependencies.values()).filter((x) => !pluginNames.has(x)));
        return missing;
      }
      /**
       * Conditionally bind browser/process events to class members.
       * The idea is to reduce event binding boilerplate in plugins.
       *
       * For efficiency we make sure the plugin is using the respective event
       * by checking the child class members before registering the listener.
       *
       * @param  {<Puppeteer.Browser>} browser
       * @param  {Object} opts - Options
       * @param  {string} opts.context - Puppeteer context (launch/connect)
       * @param  {Object} [opts.options] - Puppeteer launch or connect options
       * @param  {Array<string>} [opts.defaultArgs] - The default flags that Chromium will be launched with
       *
       * @private
       */
      async _bindBrowserEvents(browser, opts = {}) {
        if (this._hasChildClassMember("onTargetCreated") || this._hasChildClassMember("onPageCreated")) {
          browser.on("targetcreated", this._onTargetCreated.bind(this));
        }
        if (this._hasChildClassMember("onTargetChanged") && this.onTargetChanged) {
          browser.on("targetchanged", this.onTargetChanged.bind(this));
        }
        if (this._hasChildClassMember("onTargetDestroyed") && this.onTargetDestroyed) {
          browser.on("targetdestroyed", this.onTargetDestroyed.bind(this));
        }
        if (this._hasChildClassMember("onDisconnected") && this.onDisconnected) {
          browser.on("disconnected", this.onDisconnected.bind(this));
        }
        if (opts.context === "launch" && this._hasChildClassMember("onClose")) {
          if (this.onClose) {
            process.on("exit", this.onClose.bind(this));
            browser.on("disconnected", this.onClose.bind(this));
            if (opts.options.handleSIGINT !== false) {
              process.on("SIGINT", this.onClose.bind(this));
            }
            if (opts.options.handleSIGTERM !== false) {
              process.on("SIGTERM", this.onClose.bind(this));
            }
            if (opts.options.handleSIGHUP !== false) {
              process.on("SIGHUP", this.onClose.bind(this));
            }
          }
        }
        if (opts.context === "launch" && this.afterLaunch) {
          await this.afterLaunch(browser, opts);
        }
        if (opts.context === "connect" && this.afterConnect) {
          await this.afterConnect(browser, opts);
        }
        if (this.onBrowser)
          await this.onBrowser(browser, opts);
      }
      /**
       * @private
       */
      async _onTargetCreated(target) {
        if (this.onTargetCreated)
          await this.onTargetCreated(target);
        if (target.type() === "page") {
          try {
            const page = await target.page();
            if (!page) {
              return;
            }
            const validPage = "isClosed" in page && !page.isClosed();
            if (this.onPageCreated && validPage) {
              await this.onPageCreated(page);
            }
          } catch (err) {
            console.error(err);
          }
        }
      }
      /**
       * @private
       */
      _register(prototype) {
        this._registerChildClassMembers(prototype);
        if (this.onPluginRegistered)
          this.onPluginRegistered();
      }
      /**
       * @private
       */
      _registerChildClassMembers(prototype) {
        this._childClassMembers = Object.getOwnPropertyNames(prototype);
      }
      /**
       * @private
       */
      _hasChildClassMember(name) {
        return !!this._childClassMembers.includes(name);
      }
      /**
       * @private
       */
      get _isPuppeteerExtraPlugin() {
        return true;
      }
    };
  }
});

// node_modules/puppeteer-extra-plugin-stealth/index.js
var require_puppeteer_extra_plugin_stealth = __commonJS({
  "node_modules/puppeteer-extra-plugin-stealth/index.js"(exports, module) {
    var { PuppeteerExtraPlugin: PuppeteerExtraPlugin2 } = (init_index_esm(), __toCommonJS(index_esm_exports));
    var StealthPlugin = class extends PuppeteerExtraPlugin2 {
      constructor(opts = {}) {
        super(opts);
      }
      get name() {
        return "stealth";
      }
      get defaults() {
        const availableEvasions = /* @__PURE__ */ new Set([
          "chrome.app",
          "chrome.csi",
          "chrome.loadTimes",
          "chrome.runtime",
          "defaultArgs",
          "iframe.contentWindow",
          "media.codecs",
          "navigator.hardwareConcurrency",
          "navigator.languages",
          "navigator.permissions",
          "navigator.plugins",
          "navigator.webdriver",
          "sourceurl",
          "user-agent-override",
          "webgl.vendor",
          "window.outerdimensions"
        ]);
        return {
          availableEvasions,
          // Enable all available evasions by default
          enabledEvasions: /* @__PURE__ */ new Set([...availableEvasions])
        };
      }
      /**
       * Requires evasion techniques dynamically based on configuration.
       *
       * @private
       */
      get dependencies() {
        return new Set(
          [...this.opts.enabledEvasions].map((e) => `${this.name}/evasions/${e}`)
        );
      }
      /**
       * Get all available evasions.
       *
       * Please look into the [evasions directory](./evasions/) for an up to date list.
       *
       * @type {Set<string>} - A Set of all available evasions.
       *
       * @example
       * const pluginStealth = require('puppeteer-extra-plugin-stealth')()
       * console.log(pluginStealth.availableEvasions) // => Set { 'user-agent', 'console.debug' }
       * puppeteer.use(pluginStealth)
       */
      get availableEvasions() {
        return this.defaults.availableEvasions;
      }
      /**
       * Get all enabled evasions.
       *
       * Enabled evasions can be configured either through `opts` or by modifying this property.
       *
       * @type {Set<string>} - A Set of all enabled evasions.
       *
       * @example
       * // Remove specific evasion from enabled ones dynamically
       * const pluginStealth = require('puppeteer-extra-plugin-stealth')()
       * pluginStealth.enabledEvasions.delete('console.debug')
       * puppeteer.use(pluginStealth)
       */
      get enabledEvasions() {
        return this.opts.enabledEvasions;
      }
      /**
       * @private
       */
      set enabledEvasions(evasions) {
        this.opts.enabledEvasions = evasions;
      }
      async onBrowser(browser) {
        if (browser && browser.setMaxListeners) {
          browser.setMaxListeners(30);
        }
      }
    };
    var defaultExport = (opts) => new StealthPlugin(opts);
    module.exports = defaultExport;
  }
});
export default require_puppeteer_extra_plugin_stealth();
/*! Bundled license information:

for-in/index.js:
  (*!
   * for-in <https://github.com/jonschlinkert/for-in>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

for-own/index.js:
  (*!
   * for-own <https://github.com/jonschlinkert/for-own>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

merge-deep/index.js:
  (*!
   * merge-deep <https://github.com/jonschlinkert/merge-deep>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

puppeteer-extra-plugin/dist/index.esm.js:
  (*!
   * puppeteer-extra-plugin v3.2.2 by berstend
   * https://github.com/berstend/puppeteer-extra/tree/master/packages/puppeteer-extra-plugin
   * @license MIT
   *)
*/
//# sourceMappingURL=puppeteer-extra-plugin-stealth.js.map
